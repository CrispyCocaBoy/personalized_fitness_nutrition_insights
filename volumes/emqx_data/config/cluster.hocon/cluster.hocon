# This file is generated. Do not edit.
# The configs are results of online config changes from UI/API/CLI.
# To persist configs in this file, copy the content to etc/base.hocon.
actions {
  kafka_producer {
    bridge_kafka_Altimeter {
      connector = Kafka_connectors
      created_at = 1753829046237
      enable = true
      fallback_actions = []
      last_modified_at = 1753829046237
      parameters {
        buffer {
          memory_overload_protection = true
          mode = memory
          per_partition_limit = "256MB"
          segment_bytes = "10MB"
        }
        compression = no_compression
        kafka_ext_headers = []
        kafka_header_value_encode_mode = none
        max_batch_bytes = "896KB"
        max_inflight = 10
        max_linger_bytes = "10MB"
        max_linger_time = "0ms"
        message {
          key = "${.clientid}"
          timestamp = "${.timestamp}"
          value = "${.}"
        }
        partition_count_refresh_interval = "60s"
        partition_strategy = random
        partitions_limit = all_partitions
        query_mode = async
        required_acks = all_isr
        sync_query_timeout = "5s"
        topic = "wearables.altimeter.raw"
      }
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
      }
    }
    bridge_kafka_Barometer {
      connector = Kafka_connectors
      created_at = 1753829112364
      enable = true
      fallback_actions = []
      last_modified_at = 1753829112364
      parameters {
        buffer {
          memory_overload_protection = true
          mode = memory
          per_partition_limit = "256MB"
          segment_bytes = "10MB"
        }
        compression = no_compression
        kafka_ext_headers = []
        kafka_header_value_encode_mode = none
        max_batch_bytes = "896KB"
        max_inflight = 10
        max_linger_bytes = "10MB"
        max_linger_time = "0ms"
        message {
          key = "${.clientid}"
          timestamp = "${.timestamp}"
          value = "${.}"
        }
        partition_count_refresh_interval = "60s"
        partition_strategy = random
        partitions_limit = all_partitions
        query_mode = async
        required_acks = all_isr
        sync_query_timeout = "5s"
        topic = "wearables.barometer.raw"
      }
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
      }
    }
    bridge_kafka_Gyroscope {
      connector = Kafka_connectors
      created_at = 1753828916798
      enable = true
      fallback_actions = []
      last_modified_at = 1753828916798
      parameters {
        buffer {
          memory_overload_protection = true
          mode = memory
          per_partition_limit = "256MB"
          segment_bytes = "10MB"
        }
        compression = no_compression
        kafka_ext_headers = []
        kafka_header_value_encode_mode = none
        max_batch_bytes = "896KB"
        max_inflight = 10
        max_linger_bytes = "10MB"
        max_linger_time = "0ms"
        message {
          key = "${.clientid}"
          timestamp = "${.timestamp}"
          value = "${.}"
        }
        partition_count_refresh_interval = "60s"
        partition_strategy = random
        partitions_limit = all_partitions
        query_mode = async
        required_acks = all_isr
        sync_query_timeout = "5s"
        topic = "wearables.gyroscope.raw"
      }
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
      }
    }
    bridge_kafka_PPG {
      connector = Kafka_connectors
      created_at = 1753828327973
      description = ""
      enable = true
      fallback_actions = []
      last_modified_at = 1753828327973
      parameters {
        buffer {
          memory_overload_protection = true
          mode = memory
          per_partition_limit = "256MB"
          segment_bytes = "10MB"
        }
        compression = no_compression
        kafka_ext_headers = []
        kafka_header_value_encode_mode = none
        max_batch_bytes = "896KB"
        max_inflight = 10
        max_linger_bytes = "10MB"
        max_linger_time = "0ms"
        message {
          key = "${.clientid}"
          timestamp = "${.timestamp}"
          value = "${.}"
        }
        partition_count_refresh_interval = "60s"
        partition_strategy = random
        partitions_limit = all_partitions
        query_mode = async
        required_acks = all_isr
        sync_query_timeout = "5s"
        topic = "wearables.ppg.raw"
      }
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
      }
    }
    bridge_kafka_SkinTemp {
      connector = Kafka_connectors
      created_at = 1753828552715
      description = ""
      enable = true
      fallback_actions = []
      last_modified_at = 1753828552715
      parameters {
        buffer {
          memory_overload_protection = true
          mode = memory
          per_partition_limit = "256MB"
          segment_bytes = "10MB"
        }
        compression = no_compression
        kafka_ext_headers = []
        kafka_header_value_encode_mode = none
        max_batch_bytes = "896KB"
        max_inflight = 10
        max_linger_bytes = "10MB"
        max_linger_time = "0ms"
        message {
          key = "${.clientid}"
          timestamp = "${.timestamp}"
          value = "${.}"
        }
        partition_count_refresh_interval = "60s"
        partition_strategy = random
        partitions_limit = all_partitions
        query_mode = async
        required_acks = all_isr
        sync_query_timeout = "5s"
        topic = "wearables.skin-temp.raw"
      }
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
      }
    }
    bridge_kafka_accelerometer {
      connector = Kafka_connectors
      created_at = 1753828831583
      enable = true
      fallback_actions = []
      last_modified_at = 1753828831583
      parameters {
        buffer {
          memory_overload_protection = true
          mode = memory
          per_partition_limit = "256MB"
          segment_bytes = "10MB"
        }
        compression = no_compression
        kafka_ext_headers = []
        kafka_header_value_encode_mode = none
        max_batch_bytes = "896KB"
        max_inflight = 10
        max_linger_bytes = "10MB"
        max_linger_time = "0ms"
        message {
          key = "${.clientid}"
          timestamp = "${.timestamp}"
          value = "${.}"
        }
        partition_count_refresh_interval = "60s"
        partition_strategy = random
        partitions_limit = all_partitions
        query_mode = async
        required_acks = all_isr
        sync_query_timeout = "5s"
        topic = "wearables.accelerometer.raw"
      }
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
      }
    }
    bridge_kafka_cEDA {
      connector = Kafka_connectors
      created_at = 1753829185941
      enable = true
      fallback_actions = []
      last_modified_at = 1753829185941
      parameters {
        buffer {
          memory_overload_protection = true
          mode = memory
          per_partition_limit = "256MB"
          segment_bytes = "10MB"
        }
        compression = no_compression
        kafka_ext_headers = []
        kafka_header_value_encode_mode = none
        max_batch_bytes = "896KB"
        max_inflight = 10
        max_linger_bytes = "10MB"
        max_linger_time = "0ms"
        message {
          key = "${.clientid}"
          timestamp = "${.timestamp}"
          value = "${.}"
        }
        partition_count_refresh_interval = "60s"
        partition_strategy = random
        partitions_limit = all_partitions
        query_mode = async
        required_acks = all_isr
        sync_query_timeout = "5s"
        topic = "wearables.ceda.raw"
      }
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
      }
    }
  }
}
connectors {
  kafka_producer {
    Kafka_connectors {
      authentication = none
      bootstrap_hosts = "broker_kafka:9092"
      connect_timeout = "5s"
      description = "This will create a connection with the broker Kafka"
      metadata_request_timeout = "5s"
      min_metadata_refresh_interval = "3s"
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
        start_timeout = "5s"
      }
      socket_opts {
        nodelay = true
        recbuf = "1MB"
        sndbuf = "1MB"
        tcp_keepalive = none
      }
      ssl {
        enable = false
        middlebox_comp_mode = true
        verify = verify_peer
      }
    }
  }
}
log {
  console {}
  file {}
}
rule_engine {
  ignore_sys_message = true
  jq_function_default_timeout = "10s"
  rules {
    rule_kafka_Accelerometer {
      actions = [
        "kafka_producer:bridge_kafka_accelerometer"
      ]
      description = ""
      enable = true
      metadata {created_at = 1753828844752, last_modified_at = 1753828844752}
      sql = """~
        SELECT
          topic,
          payload.sensor_id as sensor_id,
          payload.timestamp as timestamp,
          payload.metric as metric,
          payload.value as value
        FROM
          "wearables/Accelerometer"~"""
    }
    rule_kafka_Altimeter {
      actions = [
        "kafka_producer:bridge_kafka_Altimeter"
      ]
      description = ""
      enable = true
      metadata {created_at = 1753829050683, last_modified_at = 1753829050683}
      sql = """~
        SELECT
          topic,
          payload.sensor_id as sensor_id,
          payload.timestamp as timestamp,
          payload.metric as metric,
          payload.value as value
        FROM
          "wearables/Altimeter"~"""
    }
    rule_kafka_Barometer {
      actions = [
        "kafka_producer:bridge_kafka_Barometer"
      ]
      description = ""
      enable = true
      metadata {created_at = 1753829116728, last_modified_at = 1753829116728}
      sql = """~
        SELECT
          topic,
          payload.sensor_id as sensor_id,
          payload.timestamp as timestamp,
          payload.metric as metric,
          payload.value as value
        FROM
          "wearables/Barometer"~"""
    }
    rule_kafka_Gyroscope {
      actions = [
        "kafka_producer:bridge_kafka_Gyroscope"
      ]
      description = ""
      enable = true
      metadata {created_at = 1753828937130, last_modified_at = 1753828937130}
      sql = """~
        SELECT
          topic,
          payload.sensor_id as sensor_id,
          payload.timestamp as timestamp,
          payload.metric as metric,
          payload.value as value
        FROM
          "wearables/Gyroscope"~"""
    }
    rule_kafka_PPG {
      actions = [
        "kafka_producer:bridge_kafka_PPG"
      ]
      description = ""
      enable = true
      metadata {created_at = 1753828330565, last_modified_at = 1753828330565}
      name = ""
      sql = """~
        SELECT
          topic,
          payload.sensor_id as sensor_id,
          payload.timestamp as timestamp,
          payload.metric as metric,
          payload.value as value
        FROM
          "wearables/PPG"~"""
    }
    rule_kafka_SkinTemp {
      actions = [
        "kafka_producer:bridge_kafka_SkinTemp"
      ]
      description = ""
      enable = true
      metadata {created_at = 1753828556662, last_modified_at = 1753828556662}
      name = ""
      sql = """~
        SELECT
          topic,
          payload.sensor_id as sensor_id,
          payload.timestamp as timestamp,
          payload.metric as metric,
          payload.value as value
        FROM
          "wearables/SkinTemp"~"""
    }
    rule_kafka_cEDA {
      actions = [
        "kafka_producer:bridge_kafka_cEDA"
      ]
      description = ""
      enable = true
      metadata {created_at = 1753829198553, last_modified_at = 1753829198553}
      sql = """~
        SELECT
          topic,
          payload.sensor_id as sensor_id,
          payload.timestamp as timestamp,
          payload.metric as metric,
          payload.value as value
        FROM
          "wearables/cEDA"~"""
    }
  }
}
