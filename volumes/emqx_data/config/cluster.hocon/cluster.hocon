# This file is generated. Do not edit.
# The configs are results of online config changes from UI/API/CLI.
# To persist configs in this file, copy the content to etc/base.hocon.
actions {
  kafka_producer {
    bridge_kafka_Altimeter {
      connector = Kafka_connectors
      created_at = 1753829046237
      description = ""
      enable = true
      fallback_actions = []
      last_modified_at = 1753829046237
      parameters {
        buffer {
          memory_overload_protection = true
          mode = memory
          per_partition_limit = "256MB"
          segment_bytes = "10MB"
        }
        compression = no_compression
        kafka_ext_headers = []
        kafka_header_value_encode_mode = none
        max_batch_bytes = "896KB"
        max_inflight = 10
        max_linger_bytes = "10MB"
        max_linger_time = "0ms"
        message {
          key = "${.clientid}"
          timestamp = "${.timestamp}"
          value = "${.}"
        }
        partition_count_refresh_interval = "60s"
        partition_strategy = random
        partitions_limit = all_partitions
        query_mode = async
        required_acks = all_isr
        sync_query_timeout = "5s"
        topic = "wearables.altimeter.raw"
      }
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
      }
    }
    bridge_kafka_Barometer {
      connector = Kafka_connectors
      created_at = 1753829112364
      description = ""
      enable = true
      fallback_actions = []
      last_modified_at = 1753829112364
      parameters {
        buffer {
          memory_overload_protection = true
          mode = memory
          per_partition_limit = "256MB"
          segment_bytes = "10MB"
        }
        compression = no_compression
        kafka_ext_headers = []
        kafka_header_value_encode_mode = none
        max_batch_bytes = "896KB"
        max_inflight = 10
        max_linger_bytes = "10MB"
        max_linger_time = "0ms"
        message {
          key = "${.clientid}"
          timestamp = "${.timestamp}"
          value = "${.}"
        }
        partition_count_refresh_interval = "60s"
        partition_strategy = random
        partitions_limit = all_partitions
        query_mode = async
        required_acks = all_isr
        sync_query_timeout = "5s"
        topic = "wearables.barometer.raw"
      }
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
      }
    }
    bridge_kafka_Gyroscope {
      connector = Kafka_connectors
      created_at = 1753828916798
      description = ""
      enable = true
      fallback_actions = []
      last_modified_at = 1753828916798
      parameters {
        buffer {
          memory_overload_protection = true
          mode = memory
          per_partition_limit = "256MB"
          segment_bytes = "10MB"
        }
        compression = no_compression
        kafka_ext_headers = []
        kafka_header_value_encode_mode = none
        max_batch_bytes = "896KB"
        max_inflight = 10
        max_linger_bytes = "10MB"
        max_linger_time = "0ms"
        message {
          key = "${.clientid}"
          timestamp = "${.timestamp}"
          value = "${.}"
        }
        partition_count_refresh_interval = "60s"
        partition_strategy = random
        partitions_limit = all_partitions
        query_mode = async
        required_acks = all_isr
        sync_query_timeout = "5s"
        topic = "wearables.gyroscope.raw"
      }
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
      }
    }
    bridge_kafka_PPG {
      connector = Kafka_connectors
      created_at = 1753828327973
      enable = true
      fallback_actions = []
      last_modified_at = 1755790838921
      parameters {
        buffer {
          memory_overload_protection = true
          mode = disk
          per_partition_limit = "256MB"
          segment_bytes = "10MB"
        }
        compression = no_compression
        kafka_ext_headers = []
        kafka_header_value_encode_mode = none
        max_batch_bytes = "896KB"
        max_inflight = 10
        max_linger_bytes = "10MB"
        max_linger_time = "0ms"
        message {
          key = "${.clientid}"
          timestamp = "${.timestamp}"
          value = "${.}"
        }
        partition_count_refresh_interval = "60s"
        partition_strategy = random
        partitions_limit = all_partitions
        query_mode = async
        required_acks = all_isr
        sync_query_timeout = "5s"
        topic = "wearables.ppg.raw"
      }
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
      }
    }
    bridge_kafka_SkinTemp {
      connector = Kafka_connectors
      created_at = 1753828552715
      enable = true
      fallback_actions = []
      last_modified_at = 1755791016117
      parameters {
        buffer {
          memory_overload_protection = true
          mode = disk
          per_partition_limit = "256MB"
          segment_bytes = "10MB"
        }
        compression = no_compression
        kafka_ext_headers = []
        kafka_header_value_encode_mode = none
        max_batch_bytes = "896KB"
        max_inflight = 10
        max_linger_bytes = "10MB"
        max_linger_time = "0ms"
        message {
          key = "${.clientid}"
          timestamp = "${.timestamp}"
          value = "${.}"
        }
        partition_count_refresh_interval = "60s"
        partition_strategy = random
        partitions_limit = all_partitions
        query_mode = async
        required_acks = all_isr
        sync_query_timeout = "5s"
        topic = "wearables.skin-temp.raw"
      }
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
      }
    }
    bridge_kafka_accelerometer {
      connector = Kafka_connectors
      created_at = 1753828831583
      enable = true
      fallback_actions = []
      last_modified_at = 1755791080313
      parameters {
        buffer {
          memory_overload_protection = true
          mode = disk
          per_partition_limit = "256MB"
          segment_bytes = "10MB"
        }
        compression = no_compression
        kafka_ext_headers = []
        kafka_header_value_encode_mode = none
        max_batch_bytes = "896KB"
        max_inflight = 10
        max_linger_bytes = "10MB"
        max_linger_time = "0ms"
        message {
          key = "${.clientid}"
          timestamp = "${.timestamp}"
          value = "${.}"
        }
        partition_count_refresh_interval = "60s"
        partition_strategy = random
        partitions_limit = all_partitions
        query_mode = async
        required_acks = all_isr
        sync_query_timeout = "5s"
        topic = "wearables.accelerometer.raw"
      }
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
      }
    }
    bridge_kafka_cEDA {
      connector = Kafka_connectors
      created_at = 1753829185941
      enable = true
      fallback_actions = []
      last_modified_at = 1755790974038
      parameters {
        buffer {
          memory_overload_protection = true
          mode = disk
          per_partition_limit = "256MB"
          segment_bytes = "10MB"
        }
        compression = no_compression
        kafka_ext_headers = []
        kafka_header_value_encode_mode = none
        max_batch_bytes = "896KB"
        max_inflight = 10
        max_linger_bytes = "10MB"
        max_linger_time = "0ms"
        message {
          key = "${.clientid}"
          timestamp = "${.timestamp}"
          value = "${.}"
        }
        partition_count_refresh_interval = "60s"
        partition_strategy = random
        partitions_limit = all_partitions
        query_mode = async
        required_acks = all_isr
        sync_query_timeout = "5s"
        topic = "wearables.ceda.raw"
      }
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
      }
    }
  }
}
connectors {
  kafka_producer {
    Kafka_connectors {
      authentication = none
      bootstrap_hosts = "broker_kafka:9092"
      connect_timeout = "5s"
      description = "This will create a connection with the broker Kafka"
      enable = true
      metadata_request_timeout = "5s"
      min_metadata_refresh_interval = "3s"
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
        start_after_created = true
        start_timeout = "5s"
      }
      socket_opts {
        nodelay = true
        recbuf = "1MB"
        sndbuf = "1MB"
        tcp_keepalive = none
      }
      ssl {
        ciphers = []
        depth = 10
        enable = false
        hibernate_after = "5s"
        log_level = notice
        middlebox_comp_mode = true
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_peer
        versions = [
          "tlsv1.3",
          "tlsv1.2"
        ]
      }
    }
  }
}
log {
  console {}
  file {}
}
mqtt {
  await_rel_timeout = "300s"
  client_attrs_init = []
  clientid_override = disabled
  exclusive_subscription = false
  idle_timeout = "15s"
  ignore_loop_deliver = false
  keepalive_check_interval = "30s"
  keepalive_multiplier = 1.5
  max_awaiting_rel = 100
  max_clientid_len = 65535
  max_inflight = 32
  max_mqueue_len = 1000
  max_packet_size = "1MB"
  max_qos_allowed = 2
  max_subscriptions = infinity
  max_topic_alias = 65535
  max_topic_levels = 128
  message_expiry_interval = infinity
  mqueue_default_priority = lowest
  mqueue_priorities = disabled
  mqueue_store_qos0 = true
  peer_cert_as_clientid = disabled
  peer_cert_as_username = disabled
  response_information = null
  retain_available = false
  retry_interval = infinity
  server_keepalive = disabled
  session_expiry_interval = "2h"
  shared_subscription = true
  shared_subscription_initial_sticky_pick = random
  shared_subscription_strategy = round_robin
  strict_mode = false
  upgrade_qos = false
  use_username_as_clientid = false
  wildcard_subscription = true
}
retainer {
  allow_never_expire = true
  backend {
    enable = true
    index_specs = [[1, 2, 3], [1, 3], [2, 3], [3]]
    max_retained_messages = 0
    storage_type = disc
    type = built_in_database
  }
  delivery_rate = "10000/s"
  max_payload_size = "1MB"
  max_publish_rate = "10000/s"
  msg_clear_interval = "0s"
  msg_expiry_interval = "0s"
  msg_expiry_interval_override = disabled
  stop_publish_clear_msg = false
}
rule_engine {
  ignore_sys_message = true
  jq_function_default_timeout = "10s"
  rules {
    rule_kafka_Accelerometer {
      actions = [
        "kafka_producer:bridge_kafka_accelerometer"
      ]
      description = ""
      enable = true
      metadata {last_modified_at = 1755789642019}
      name = ""
      sql = """~
        SELECT
          topic,
          payload.sensor_id as sensor_id,
          payload.timestamp as timestamp,
          payload.metric as metric,
          payload.value as value
        FROM
          "wearables/Accelerometer"~"""
    }
    rule_kafka_Altimeter {
      actions = [
        "kafka_producer:bridge_kafka_Altimeter"
      ]
      description = ""
      enable = false
      metadata {last_modified_at = 1755789296362}
      name = ""
      sql = """~
        SELECT
          topic,
          payload.sensor_id as sensor_id,
          payload.timestamp as timestamp,
          payload.metric as metric,
          payload.value as value
        FROM
          "wearables/Altimeter"~"""
    }
    rule_kafka_Barometer {
      actions = [
        "kafka_producer:bridge_kafka_Barometer"
      ]
      description = ""
      enable = false
      metadata {last_modified_at = 1755789295947}
      name = ""
      sql = """~
        SELECT
          topic,
          payload.sensor_id as sensor_id,
          payload.timestamp as timestamp,
          payload.metric as metric,
          payload.value as value
        FROM
          "wearables/Barometer"~"""
    }
    rule_kafka_Gyroscope {
      actions = [
        "kafka_producer:bridge_kafka_Gyroscope"
      ]
      description = ""
      enable = false
      metadata {last_modified_at = 1755792314236}
      name = ""
      sql = """~
        SELECT
          topic,
          payload.sensor_id as sensor_id,
          payload.timestamp as timestamp,
          payload.metric as metric,
          payload.value as value
        FROM
          "wearables/Gyroscope"~"""
    }
    rule_kafka_PPG {
      actions = [
        "kafka_producer:bridge_kafka_PPG"
      ]
      description = ""
      enable = true
      metadata {last_modified_at = 1755789720151}
      name = ""
      sql = """~
        SELECT
          topic,
          payload.sensor_id as sensor_id,
          payload.timestamp as timestamp,
          payload.metric as metric,
          payload.value as value
        FROM
          "wearables/PPG"~"""
    }
    rule_kafka_SkinTemp {
      actions = [
        "kafka_producer:bridge_kafka_SkinTemp"
      ]
      description = ""
      enable = true
      metadata {last_modified_at = 1755789639486}
      name = ""
      sql = """~
        SELECT
          topic,
          payload.sensor_id as sensor_id,
          payload.timestamp as timestamp,
          payload.metric as metric,
          payload.value as value
        FROM
          "wearables/SkinTemp"~"""
    }
    rule_kafka_cEDA {
      actions = [
        "kafka_producer:bridge_kafka_cEDA"
      ]
      description = ""
      enable = true
      metadata {last_modified_at = 1755789638821}
      name = ""
      sql = """~
        SELECT
          topic,
          payload.sensor_id as sensor_id,
          payload.timestamp as timestamp,
          payload.metric as metric,
          payload.value as value
        FROM
          "wearables/cEDA"~"""
    }
  }
}
slow_subs {
  enable = true
  expire_interval = "300s"
  stats_type = whole
  threshold = "500ms"
  top_k_num = 10
}
